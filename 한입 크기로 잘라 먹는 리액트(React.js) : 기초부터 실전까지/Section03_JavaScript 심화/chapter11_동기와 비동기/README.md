## 동기와 비동기

### **동기(Synchronous)란?**
- 여러 작업이 있을 때 **순서대로 하나씩만 처리**하는 방식.
- 자바스크립트는 기본적으로 동기적으로 동작하며, **코드가 위에서 아래로 실행**됨.
- **Thread**: 작업을 처리하고 실행하는 역할을 수행.
- **동기적 처리**란 여러 작업을 하나씩 차례로 처리하는 실행 방식.

#### **예제1: 동기적인 코드 실행**
```javascript
console.log(1);
console.log(2);
console.log(3);
// 결과: 1, 2, 3
```

#### **예제2: 함수 호출도 동기적으로 실행**
```javascript
function taskA() {
  console.log("2");
}
console.log("1");
taskA();
console.log("3");
// 결과: 1, 2, 3
```

- 자바스크립트 엔진은 기본적으로 **모든 코드를 순서대로 동기적으로 실행**하기 때문에 코드를 읽을 때 위에서 아래로 실행된다고 이해할 수 있다.

# 

### **동기적 방식의 단점**
- 동기적인 방식에서는 하나의 작업이 끝나야만 다음 작업으로 넘어간다. 

- **예제: 작업 시간에 따른 문제**
  ```javascript
  function taskA() {
    console.log("Task A 시작");
    // 시간이 오래 걸리는 작업
    let now = Date.now();
    while (Date.now() - now < 5000) {}
    console.log("Task A 끝");
  }
  function taskB() {
    console.log("Task B 실행");
  }
  function taskC() {
    console.log("Task C 실행");
  }
  
  taskA(); // 5초 동안 멈춤
  taskB();
  taskC();
  // 결과:
  // Task A 시작
  // (5초 대기)
  // Task A 끝
  // Task B 실행
  // Task C 실행
  ```

  - **단점**:
    - `taskA`가 실행되는 동안 `taskB`와 `taskC`는 대기 상태가 된다.
    - 작업 시간이 길어지면 전체 프로그램의 성능이 저하된다.

#### **다른 언어에서의 해결 방법**:
- Java, C#: **멀티스레드** 방식을 사용하여 여러 스레드에서 작업을 병렬로 처리.

#### **자바스크립트의 해결 방법: 비동기**
- 자바스크립트는 싱글 스레드 기반이지만, **비동기 처리 방식**으로 이러한 문제를 해결.

# 

### **비동기(Asynchronous)란?**
- 여러 작업이 있을 때 **순서대로 처리하지 않고**, 앞선 작업이 완료되지 않아도 **다른 작업을 동시에 진행**하는 방식.

#### **예제: 비동기 코드 실행**
```javascript
console.log(1);

setTimeout(() => {
  console.log(2); // 비동기 실행
}, 3000);

console.log(3);
// 결과: 1, 3, 2
```

#### **설명**:
- `setTimeout`은 비동기 함수로, 코드 실행 중 **특정 작업을 지연시켜 실행**함.
- 타이머가 완료될 때까지 기다리지 않고 다음 코드를 바로 실행.

# 

#### **비동기가 가능한 이유**
자바스크립트는 **싱글 스레드**이지만, 비동기 작업은 **Web APIs**라는 브라우저가 관리하는 영역에서 처리된다.

#### **Web APIs란?**
- 브라우저에서 제공하는 별도의 공간으로, **비동기 작업을 실행하는 영역**.
- `setTimeout`, `fetch`, `DOM 이벤트` 등은 Web APIs가 관리한다.
> https://www.notion.so/Web-APIs-1711c69c9ddf806fa760c427461d91e5

# 

### **비동기 코드의 실행 순서**
1. **자바스크립트 엔진(JS Engine)**: 코드를 한 줄씩 실행.
2. **비동기 함수**(`setTimeout` 등)을 만나면 해당 작업을 **Web APIs**로 전달하고, 아래 코드를 계속 실행.
3. **Web APIs**는 작업을 처리하고, 완료 시 **콜백 함수**를 준비.
4. 작업이 끝난 콜백 함수는 **이벤트 큐(Event Queue)** 에 저장.
5. **JS 엔진의 콜 스택**이 비어 있을 때 이벤트 큐에 있는 콜백 함수를 가져와 실행.

#### **예제**
```javascript
console.log(1);

setTimeout(() => {
  console.log(2); // Web APIs에서 관리
}, 3000);

console.log(3);
// 결과: 1, 3, 2
```
#### **실행 흐름:**
1. `console.log("작업 1 시작")` 실행 → 출력: `작업 1 시작`.
2. `setTimeout` 호출 → 타이머 작업이 **Web APIs**로 전달됨.
3. `console.log("작업 1 끝")` 실행 → 출력: `작업 1 끝`.
4. 2초 후, 타이머 완료 → 콜백 함수가 콜백 큐로 이동.
5. 이벤트 루프가 메인 스레드가 비어 있음을 확인하고, 콜백 함수 실행 → 출력: `2초 후 실행되는 작업`.

# 

### **비동기 처리의 장점**
1. **작업 병렬 처리 가능**:
   - 느린 작업이 프로그램 전체 실행을 방해하지 않음.
2. **효율적인 자원 사용**:
   - 긴 대기 작업 중에도 다른 작업을 처리 가능.

# 

### **비동기와 동기의 비교**
| 구분          | 동기 방식                                      | 비동기 방식                                |
|---------------|-----------------------------------------------|------------------------------------------|
| 처리 방식     | 작업을 순서대로 하나씩 처리                    | 작업을 기다리지 않고 다음 작업으로 넘어감   |
| 실행 순서     | 작성된 코드 순서대로 실행                      | 작성된 순서와 실행 순서가 다를 수 있음     |
| 프로그램 성능 | 작업 시간이 길어지면 프로그램 성능 저하         | 병렬로 작업을 처리해 성능 저하를 방지      |
| 사용 예시     | 일반적인 함수 호출                            | `setTimeout`, `fetch`, 이벤트 리스너 등   |

# 
