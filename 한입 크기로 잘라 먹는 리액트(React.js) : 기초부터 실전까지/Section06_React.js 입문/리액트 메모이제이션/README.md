# 리액트 메모이제이션
- **불필요한 렌더링을 방지하여 성능을 최적화**하기 위해 사용하는 기술입니다.
- 리액트에서는 기본적으로 상태(state)나 속성(props)이 변경될 때마다 컴포넌트가 리렌더링됩니다.
  - 하지만 경우에 따라 렌더링이 필요하지 않은데도 재렌더링되는 일이 발생할 수 있습니다.
- 이를 방지하기 위해 `React.memo`, `useCallback`, `useMemo` 같은 메모이제이션 도구를 사용합니다.

# 

## **1. React.memo**
#### **역할**: 
- `React.memo`는 **함수형 컴포넌트를 메모이제이션**하여, **props가 변경되지 않으면 재렌더링을 방지**합니다.

#### **사용법**:
  ```jsx
  const MyComponent = React.memo((props) => {
    console.log("렌더링");
    return <div>{props.value}</div>;
  });
  ```

#### **작동 원리**:
  - `React.memo`는 **props를 얕은 비교(Shallow Comparison)** 합니다.
  - 이전 props와 새 props가 같으면 컴포넌트를 재렌더링하지 않고, 기존 결과를 재사용합니다.

#### **주의사항**:
  - **참조형 데이터(객체, 배열)** 는 값이 같더라도 새로운 참조가 생성되면 렌더링이 일어날 수 있습니다.
  - 이를 방지하기 위해 `useMemo`나 `useCallback`과 함께 사용하는 경우가 많습니다.

# 

## **2. useCallback**
#### **역할**: 
- `useCallback`은 **함수를 메모이제이션**합니다. 함수가 불필요하게 재생성되는 것을 방지하고, 자식 컴포넌트로 props를 전달할 때 유용합니다.

#### **사용법**:
  ```jsx
  const handleClick = useCallback(() => {
    console.log("클릭");
  }, []); // 의존성 배열
  ```

#### **작동 원리**:
  - 의존성 배열의 값이 변경되지 않는 한, **같은 함수 객체를 반환**합니다.

#### **사용 예시**
- 자식 컴포넌트에 콜백 함수를 props로 전달할 때 유용합니다.
  ```jsx
  const Parent = () => {
    const [count, setCount] = useState(0);

    const increment = useCallback(() => {
      setCount((prev) => prev + 1);
    }, []);

    return <Child onClick={increment} />;
  };
  ```

# 

## **3. useMemo**
#### **역할**: 
- `useMemo`는 **값을 메모이제이션**합니다. 복잡한 계산이 반복적으로 실행되는 것을 방지하고 성능을 최적화합니다.

#### **사용법**:
  ```jsx
  const memoizedValue = useMemo(() => {
    return computeExpensiveValue(a, b);
  }, [a, b]); // 의존성 배열
  ```

#### **작동 원리**:
  - 의존성 배열의 값이 변경되지 않는 한, `useMemo`는 **계산된 값을 캐싱**하여 기존 값을 반환합니다.

#### **사용 예시**: 
- 렌더링 시 반복 계산을 줄이고 싶을 때 사용.
  ```jsx
  const Example = ({ list }) => {
    const sortedList = useMemo(() => {
      console.log("리스트 정렬");
      return list.sort();
    }, [list]);

    return <div>{sortedList.join(", ")}</div>;
  };
  ```

# 

## **React.memo, useCallback, useMemo의 차이점**
| **도구**       | **목적**                               | **적용 대상**          | **사용 사례**                                                                 |
|----------------|---------------------------------------|------------------------|------------------------------------------------------------------------------|
| React.memo     | 컴포넌트 메모이제이션                 | 함수형 컴포넌트         | 부모 컴포넌트의 렌더링으로 인해 자식 컴포넌트가 불필요하게 렌더링되는 경우 |
| useCallback    | 함수 메모이제이션                     | 콜백 함수               | 자식 컴포넌트로 props를 전달할 때 같은 함수 객체를 유지                    |
| useMemo        | 값(결과) 메모이제이션                  | 계산된 값               | 렌더링 시 복잡한 계산을 최적화하고 싶을 때                                 |

# 

## **언제 사용해야 할까?**
- `React.memo`:
  - 자식 컴포넌트가 불필요하게 렌더링되는지 확인 후 적용.
- `useCallback`:
  - 자식 컴포넌트에 콜백 함수를 전달하거나, 이벤트 핸들러를 메모이제이션해야 할 때.
- `useMemo`:
  - 계산 비용이 높은 작업이 반복적으로 실행될 때.

---

## **결론**
리액트 메모이제이션 도구는 렌더링 성능 최적화를 위해 강력하지만, 남용하면 코드 복잡도가 증가하고 관리가 어려워질 수 있습니다. **성능 문제를 명확히 확인**한 후, **필요한 경우에만 사용**하는 것이 좋습니다.
